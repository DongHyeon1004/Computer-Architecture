# 메모리와 캐시 메모리

# RAM의 특징

- 실행할 프로그램의 명령어와 데이터가 저장
- **휘발성 저장 장치** : 전원을 끄면 저장된 내용이 사라지는 저장 장치

**비휘발성 저장 장치** : 전원이 꺼져도 저장된 내용이 유지되는 저장 장치

ex) 하드 디스크, SSD, CD-ROM, USB 메모리 등 보조 기억 장치

CPU는 보조 기억 장치에 직접적으로 접근 불가.

보조 기억 장치에는 **보관할 대상** 저장, RAM에는 **실행할 대상**을 저장.

CPU가 실행하고 싶은 프로그램이 보조 기억 장치에 있다면 RAM으로 복사해 저장하고 실행.

---

# RAM의 용량과 성능

RAM의 용량이 충분히 크다면 보조 기억 장치에서 많은 데이터를 미리 가져와 RAM에 저장할 수 있어 많은 프로그램을 동시에 빠르게 실행하는데 유리하다.

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/6-1.png)

RAM 용량이 커지면 프로그램 실행 속도가 어느 정도 증가하지만, 용량이 필요 이상으로 커졌을 때는 속도가 그에 비례하여 증가하지는 않는다.

---

# RAM의 종류

### DRAM(Dynamic RAM)

- 시간이 지나면 저장된 데이터가 점차 사라짐.
- 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화해야 함.
- 소비 전력이 비교적 낮고, 저렴하고, 집적도가 높기 때문에 대용량으로 설계하기가 용이함.

### SRAM(Static RAM)

- 시간이 지나도 저장된 데이터가 사라지지 않음.
- 주기적인 데이터 재활성화가 필요하지 않음.
- DRAM보다 일반적으로 속도가 더 빠름.
- DRAM보다 집적도가 낮고, 소비 전력이 크고, 가격도 더 비쌈.
- 메모리가 아닌 대용량으로 만들어질 필요는 없지만 속도가 빨라야 하는 저장 장치(캐시 메모리)에 사용됨.

### SDRAM(Synchronous Dynamic RAM)

- 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 발전된 형태의 DRAM.

### DDR SDRAM(Double Data Rate SDRAM)

- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
    
    **대역폭** : 데이터를 주고받는 길의 너비
    
- SDRAM에 비해 두 배의 대역폭으로 한 클럭당 두 번씩 CPU와 데이터를 주고받을 수 있고, 데이터 전송 속도가 SDRAM보다 두 배가량 빠름.
- **SDR SDRAM** : 한 클럭당 하니씩 데이터를 주고받을 수 있는 SDRAM

---

# 물리 주소와 논리 주소

**물리 주소** : 메모리 하드웨어가 사용하는 주소, 정보가 실제로 저장된 하드웨어상의 주소

**논리 주소** : CPU와 실행 중인 프로그램이 사용하는주소, 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소 

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/6-2.png)

CPU가 이해하는 주소가 논리 주소라고 해도 메모리와 상호작용하려면 논리 주소와 물리 주소 간의 변환이 필요하다.

**메모리 관리 장치(MMU)** : 논리 주소와 물리 주소 간의 변환을 수행하는 CPU와 주소 버스 사이에 위치한 하드웨어

- CPU가 발생시킨 논리 주소에 베이스 레지스터 값**(프로그램의 가장 작은 물리 주소)**을 더하여 논리 주소를 물리 주소로 변환한다.
- 논리 주소는 프로그램의 시작점으로부터 떨어진 거리

---

# 메모리 보호 기법

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/6-3.png)

**한계 레지스터** : 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는 레지스터

- 논리 주소의 최대 크기 저장.
- 베이스 레지스터 값 ≤ 프로그램의 물리 주소 < 베이스 레지스터 값 + 한계 레지스터 값
- CPU가 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지 항상 검사를 하고, 만약 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터럽트를 발생시켜 실행을 중단한다.

---

# 저장 장치 계층 구조

저장 장치가 따르는 명제

1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
2. 속도가 빠른 저장 장치는 용량이 작고, 가격이 비싸다.

- CPU와 가장 가까운 레지스터는 RAM보다 용량은 작고, 접근 시간이 압도적으로 빠르다. 가격이 비싸다.
- RAM은 USB 메모리보다 CPU에 더 가까워 접근 시간이 훨씬 빠르고, 같은 용량이라 할지라도 가격이 더 비싸다.

**저장 장치 계층 구조** : 컴퓨터가 사용하는 저장 장치들을 **CPU에 얼마나 가까운가**를 기준으로 계층적으로 나타낸 것

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/6-4.png)

---

# 캐시 메모리

**캐시 메모리** : CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 빠른 SRAM 기반의 저장 장치

- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생.
- CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/6-5.png)

**L1 캐시** : CPU와 가장 가까운 캐시 메모리

**L2 캐시** : 그 다음 가까운 캐시 메모리

**L3 캐시** : 그 다음 가까운 캐시 메모리

일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치

---

# 참조 지역성 원리

- 캐시 메모리는 메모리보다 용량이 작아 메모리의 모든 내용을 저장할 수는 없다.
- 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장한다.

**캐시 히트** : 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용되는 경우

**캐시 미스** : 자주 사용될 것이라고 예측해 저장했지만, 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우

**캐시 적중률** : 캐시가 히트되는 비율

```java
캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
```

- 캐시 메모리는 참조 지역성 원리에 따라 메모리로부터 가져올 데이터를 결정한다.

**참조 지역성 원리** : CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리

1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

### **최근에 접근했던 메모리 공간에 다시 접근하려는 경향?**

- 변수에 값을 저장하면 언제든 변수에 다시 접근하여 변수에 저장된 값을 사용할 수 있다.
    
    → CPU는 변수가 저장된 메모리 공간을 언제든 다시 참조할 수 있다.
    

- 변수에 저장된 값은 일반적으로 한 번만 사용되지 않고 프로그램이 실행되는 동안 여러번 사용된다.
    
    → CPU는 최근에 접근했던(변수가 저장된) 메모리 공간을 여러 번 다시 접근할 수 있다.
    

```c
#include <stdio.h>

int main(void)
{
		int num = 2;
		
		for (int i = 1; i <= 9; i++)
				printf("%d X %d = %d\n", num, i, num * i);
		retrun 0;
}
```

변수인 num과 i가 여러 번 사용되고 있다.

**시간 지역성** : 최근에 접근했던 메모리 공간에 다시 접근하려는 경향

### **접근한 메모리 공간 근처를 접근하려는 경향?**

- CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 모여 있다.
- 하나의 프로그램 내에서도 관련 있는 데이터들은 모여서 저장된다.
- CPU가 프로그램을 실행할 때는 그 프로그램이 모여 있는 공간 근처를 집중적으로 접근한다.
- 사용자가 입력을 할 때는 입력 기능이 모여 있는 공간 근처를 집중적으로 접근한다.

**공간 지역성** : 접근한 메모리 공간 근처를 접근하려는 경향
