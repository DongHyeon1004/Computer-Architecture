# 명령어

## 고급 언어

**사람이 이해하고  작성하기 쉽게 만들어진 언어**

ex) C, C++, Java, Python

## 저급 언어

**컴퓨터가 직접 이해하고 실행할 수 있는 언어**

컴퓨터는 저급 언어만 이해하기 때문에 고급 언어는 반드시 저급 언어(명령어)로 전환해줘야 함

저급 언어의 두 가지 종류

- 기계어 : 0과 1로 이루어진 명령어 비트
- 어셈블리어 : 기계어를 읽기 편한 형태로 번역한 저급 언어

---

## 컴파일 언어

**컴파일 방식으로 작동하는 프로그래밍 언어**

컴파일 : 작성된 소스 코드 전체가 저급 언어로 변환되는 과정

전체가 변환되기 때문에 실행 속도가 빠르지만, 단 하나의 오류라도 있으면 컴파일이 불가능

## 인터프리터 언어

**인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어**

인터프리터 : 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구

코드가 한 줄씩 변환되기 때문에 실행 속도가 느리지만, 오류가 발생하기 전까지는 수행

---

## 명령어의 구조

**명령어 = 연산 코드 + 오퍼랜드**

- **연산 코드** : 명령어가 수행할 연산을 의미, “연산자”라고 함
- **연산 코드 필드** : 연산 코드가 담기는 영역
- **오퍼랜드** : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치, “피연산자”라고 함.              많은 경우에 메모리 주소나 레지스터 이름이 담기기에 “주소 필드”라고 함.                                      오퍼랜드의 개수에 따라서 n-주소 명령어라고 한다
- **오퍼랜드 필드** : 오퍼랜드가 담기는 영역

## 데이터 전송 연산 코드

- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라

## 산술/논리 연산 코드

- ADD, SUBTRACT, MULTIPLY, DEVIDE : 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하라
- INCREMENT, DECREMENT : 오퍼랜드에 1을 더하라, 빼라
- AND, OR, NOT : 이 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라

## 제어 흐름 변경 연산 코드

- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

## 입출력 제어 연산 코드

- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

---

## 주소 지정 방식& 유효 주소

**유효 주소** : 연산 코드에 사용할 데이터가 저장된 위치

**주소 지정 방식** : 유효 주소를 찾는 5가지 방법

오퍼랜드의 개수가 늘어날수록 n-주소 명령어에서 표현할 수 있는 데이터의 크기가 줄어든다 

## 즉시 주소 지정 방식

**연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식, 가장 간단한 형태**

장점 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 실행 속도가 빠름.

단점 : 표현할 수 있는 데이터 크기가 작아진다.

## 직접 주소 지정 방식

**오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식**

장점 : 표현할 수 있는 데이터의 크기가 커짐. 

단점 : 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현 가능한 유효 주소에 제한이 생길 수 있음

## 간접 주소 지정 방식

**유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식**

장점: 표현 가능한 유효 주소의 범위는 커짐.

단점: 두 번의 메모리 접근이 필요해 다른 방식에 비해 속도가 느림.

## 레지스터 주소 지정 방식

**연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식**

장점 :  메모리에 접근하는 것 보다 CPU 내부에 레지스터에 접근하는 것이 빨라 데이터에 빠르게 접근 가능

단점 : 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음

## 레지스터 간접 주소 지정 방식

**연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식**

장점 : 메모리에 접근하는 횟수가 한 번으로 줄어들어 속도가 빠름