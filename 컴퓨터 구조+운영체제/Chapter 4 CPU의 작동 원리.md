# CPU의 작동 원리

# ALU

레지스터를 통해 피연산자를 받아들이고, 제어 장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.

CPU가 메모리에 접근하는 속도가 레지스터에 접근하는 속도보다 매우 느리기 때문에 결과값을 **메모리가 아닌 레지스터에 저장한다.**

결과값과 더불어 **연산 결과에 대한 추가적인 상태 정보**인 **플래그**를 내보낸다.

### **플래그의 종류**

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/4-1.png)

**플래그 레지스터** : 플래그 값들을 저장하는 레지스터

---

# 제어장치

**제어장치** : 제어신호를 내보내고 명령어를 해석하는 부품

### 제어장치가 받아들이는 정보

1. **클럭 신호**
    
    **클럭** : 컴퓨터의 모든 부품이 맞춰서 작동하는 시간 단위
    
    **컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동 ≠ 컴퓨터의 모든 부품이 한 클럭마다 작동**
    
    클럭이라는 박자에 맞춰서 작동할 뿐 박자마다 작동하는 것이 아니다.
    
    하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있다.
    
2. **해석해야 할 명령어**
    
    CPU가 해석해야 할 명령어는 **명령어 레지스터**에 저장되는데, 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시킨다. 
    
3. **플래그 레지스터 속 플래그 값**
    
    ALU 연산에 대한 추가적인 상태 정보인 플래그 값을 받아들이고 이를 참고해서 제어 신호를 발생시킨다.
    
4. **제어 버스로 전달된 제어 신호**
    
    제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.
    

### 제어장치가 내보내는 정보

- CPU 외부에 전달하는 신호
    - 제어 버스로 제어 신호를 내보낸다.
    - 메모리에 전달하는 제어 신호 : 메모리에 저장된 값을 읽거나 새로운 값을 쓸 때
    - 입출력 장치에 전달하는 제어 신호 : 입출력장치의 값을 읽거나 새로운 값을 쓸 때

- CPU 내부에 전달하는 신호
    - ALU에 전달하는 제어 신호 : 수행할 연산 지시
    - 레지스터에 전달하는 제어 신호 : 레지스터 간 데이터를 이동시키거나 저장된 명령어를 해석

---

# 레지스터

**CPU 내부에 있는 작은 임시 저장 장치**.

종류마다 역할과 저장 내용이 다르고, CPU마다 이름과 크기가 다양하다.

### 대표적인 레지스터의 종류

- **프로그램 카운터** : 메모리에서 읽어 들일 명령어의 주소를 저장. 명령어 포인터라고도 함.
- **명령어 레지스터** : 메모리에서 읽어 들인 명령어를 저장.
- **메모리 주소 레지스터** : 메모리 주소 저장, 이 레지스터를 거쳐서 메모리 주소 버스로 감.
- **메모리 버퍼 레지스터** : 메모리와 주고받을 데이터와 명령어를 저장. 이 레지스터를 거쳐서 데이터 버스로 감. CPU에 따라서 메모리 데이터 레지스터라고도 함.
- **범용 레지스터** : 다양하고 일반적인 상황에서 자유롭게 사용하는 레지스터, 데이터와 주소 모두 저장 가능. 일반적으로 여러 개 존재.
- **플래그 레지스터** : 플래그를 저장.
- **스택 포인터** : 스택 주소 지정 방식을 사용하는 레지스터.
- **베이스 레지스터** : 베이스 주소 지정 방식을 사용하고, 기준 주소로 사용하는 레지스터.

---

# 주소 지정 방식

### 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식

**스택** : 한쪽 끝이 막혀 있는 통 같은 저장 공간, 최근에 저장하는 값부터 꺼낼 수 있음.

**스택 포인터** : 스택의 꼭대기를 가리키는 레지스터. 스택에 마지막으로 저장한 값의 위치를 저장.

**스택 영역** : 메모리 안에 스택처럼 사용할 영역

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/4-2.png)

### 변위 주소 지정 방식

변위와 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

**변위** : 오퍼랜드 필드 값

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/4-3.png)

1. **상대 주소 지정 방식**

오퍼랜드와 프로그램 카운터의 값을 더해서 유효 주소를 얻는 방식

음수는 읽어 들이기로 한 명령어로부터 n번째 전 의미.

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/4-4.png)

1. **베이스 레지스터 주소 지정 방식**

오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

**베이스 레지스터** : 기준 주소

**오퍼랜드** : 기준 주소로부터 떨어진 거리

베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식

![Untitled](https://github.com/DongHyeon1004/Computer-Structure/blob/main/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B5%AC%EC%A1%B0%2B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/image/4-5.png)
---

# 명령어 사이클

**명령어 사이클** : 하나의 명령어를 처리하는 정형화된 흐름

- 인출 사이클 : 패치 사이클, 메모리에 있는 명령어를 CPU에 가져오는 단계
- 실행 사이클 : 가져온 명령어를 실행하는 단계, 간단한 명령일 경우 인출 실행 사이클로 실행.
- 간접 사이클 : 명령어를 실행하기 위해서 메모리 접근을 한 번 더 하는 단계
- 인터럽드 사이클 : 인터럽트를 처리하는 단계

# 인터럽트

**인터럽트** : 흐름이 끊어지는 상황, CPU의 작업을 방해하는 신호

1. **동기 인터럽트(예외)**

CPU에 의해 발생하는 인터럽트

프로그래밍상의 오류와 같은 예외적인 상황을 마주쳤을 때 발생한다. 

작업을 중지한 후 예외를 처리하고 다시 실행

- **폴트** : 처리 후 예외가 발생한 명령어부터 다시 실행
- **트랩** : 처리 후 예외가 발생한 명령어 다음부터 실행
- **중단** : 실행중인 프로그램을 강제로 중단해야 할 만큼 심한 오류일 경우
- **소프트 인터럽트** : 시스템 호출이 발생했을 때

1. **비동기 인터럽트(하드웨어 인터럽트)**

입출력 장치로 인해 발생하는 인터럽트

CPU에 입출력 장치가 작업이 끝났다고 보내는 알림 같은 인터럽트, 작업에 효율적이다.

- 막을 수 있는 인터럽트
- 막을 수 없는 인터럽트

### 인터럽트 처리 과정

인터럽트 플래그가 활성화가 되어야 처리한다.

1. 처리 할 수 있다고 사인이 떨어지면 CPU가 스택에 작업 정보를 백업
2. 프로그램 카운터에 인터럽트 서비스 루틴의 주소를 넣어서 매뉴얼대로 처리.
3. 서비스 루틴이 끝나면 작업들을 백업, 복구해서 다시 작업 실행.
