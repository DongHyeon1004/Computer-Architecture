# CPU 스케줄링

**CPU 스케줄링(CPU scheduling)** : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

프로세스들에게 현명하게 CPU를 배분하지 못하면 반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생할 수 있다.

---

# 프로세스 우선순위

프로세스마다 우선순위가 다르기 때문에 CPU를 사용하고 싶어 하는 프로세스들이 차례로 돌아가며 CPU를 이용하게 하는 것은 좋은 방법이 아니다.

**우선순위가 높은 프로세스** : 빨리 처리해야 하는 프로세스. 대표적으로 입출력 작업이 많은 프로세스

**입출력 작업이 많은 프로세스를 먼저 실행하는 것이 효율적인 이유**

![Untitled](CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20f06ea55ecb16459f8dda86c430c5c4af/Untitled.png)

프로세스 종류마다 입출력 장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.

- **입출력 집중 프로세스(I/O bound process)** : 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스. 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 된다.
- **CPU 집중 프로세스(CPU bound process)** : 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스. 대기 상태보다는 실행 상태에 더 많이 머무르게 된다.
- **CPU 버스트(CPU burst)** : CPU를 이용하는 작업
- **입출력 버스트(I/O burst)** : 입출력 장치를 기다리는 작업

CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다면, 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력 장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다.

입출력 장치가 입출력 작업을 완료하기 전까지 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 먼저 처리하면 다른 프로세스가 CPU를 사용할 수 있기 때문이다.

운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

---

# 스케줄링 큐

PCB에 우선순위가 적혀 있지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다. CPU를 요구하는 새로운 프로세스는 언제든지 생길 수 있기 때문이다.

**스케줄링 큐** : 운영체제가 CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력 장치를 사용하고 싶은 프로세스들을 모두 줄을 세우는 것을 구현하고 관리하기 위해 사용하는 것.

ex)

![Untitled](CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20f06ea55ecb16459f8dda86c430c5c4af/Untitled%201.png)

운영체제가 관리하는 대부분의 자원은 큐로 관리된다.

**운영체제가 관리하는 대표적인 큐**

- **준비 큐(ready queue)** : CPU를 이용하고 싶은 프로세스들이 서는 줄
- **대기 큐(waiting queue)** : 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다.

운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.

대기 상태에 있는 프로세스들도 마찬가지로 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다린다.

입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거하고 제거된 PCB는 준비 큐로 이동한다.

---

# 선점형과 비선점형 스케줄링

**선점형 스케줄링(preemptive scheduling)** : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식. 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식. 

- **장점** : 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있다.
- **단점** : 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

**비선점형 스케줄링(non-preemptive scheduling)** : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식. 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식.

- **장점** : 문맥 교환의 횟수가 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적다.
- **단점** : 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야 하고, 모든 프로세스가 골고루 자원을 사용할 수 없다

---

# 스케줄링 알고리즘의 종류

1. **선입 선처리 스케줄링(FCFS 스케줄링; First come First Served Scheduling)**
    - 단순히 준비된 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식.
    - 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식.
    - 가장 공정해 보이지만, 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다.
    - **호위 효과(convoy effect)** : CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다리게 되는 현상
    
2. **최단 작업 우선 스케줄링(SJF 스케줄링; Shortest Job First Scheduling)**
    - 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식.
    - 호위 효과를 방지할 수 있다.
    - 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있다.
    
3. **라운드 로빈 스케줄링(round robin scheduling)**
    - 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식.
    - **타임 슬라이스** : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간.
    - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링 방식.
    - 타임 슬라이스가 지나치게 크면 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 수 있고, 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 힘을 다 쓸 수 있기 때문에 **타임 슬라이스의 크기가 매우 중요하다.**
    
4. **최소 잔여 시간 우선 스케줄링(SRT 스케줄링; Shortest Remaining Time Scheduling)**
    - 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식.
    - 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스 만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.
    
5. **우선순위 스케줄링(priority scheduling)**
    - 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘.
    - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링된다.
    - 최단 작업 우선 스케줄링 / 최소 잔여 시간 우선 스케줄링 알고리즘은 넓은 의미에서 우선순위 스케줄링의 일종이다.
    - **기아 현상** : 우선순위가 높은 프로세스를 우선하여 처리하는 방식이기에 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입됐음에도 불구하고 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기되는 현상. 우선순위 스케줄링의 근본적인 문제
    - **에이징** : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식. 기아 현상을 방지하기 위한 대표적인 기법
    
6. **다단계 큐 스케줄링(multilevel queue scheduling)**
    - 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식. 우선순위 스케줄링의 발전된 형태.
    - 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.
    - 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다.
    - 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.
    - 프로세스들이 큐 사이를 이동할 수 없기 때문에 기아 현상이 발생할 수 있다.
    
7. **다단계 피드백 큐 스케줄(multilevel feedback queue scheduling)**
    - 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘. 다단계 큐 스케줄링의 발전된 형태.
    - 다단계 큐 스케줄링과 비슷하게 작동하지만, 프로세스들이 큐 사이를 이동할 수 있다.
    - 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행된다.
    - 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.
    - 즉, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행된다.
    - 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.